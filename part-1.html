<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Compilers - Frontend</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<small>Compilers Crash Course &mdash; Part 1:</small>
					<h1>The Frontend</h1>
					<p>Lexical analysis, parsing, AST analysis, optimisations, interpreters, transpilation</p>
				</section>

				<section>
					<h2>Target Language</h2>
					<p>Building a toolchain for parts of JavaScript (ES5 first)</p>
					<p class="fragment">Not precisely the ES5 spec, because some simplifications might be necessary</p>

					<aside class="notes">
						<p>
							Sounds crazy? I won't implement <em>every</em> part, just small subsets to demonstrate
							concepts.
						</p>
						<p>
							Also, I'll appeal to your intuition of what the semantics ought to be. I will clarify if
							there is a need.
						</p>
					</aside>
				</section>

				<section>
					<h2>Overview</h2>
				</section>

				<section>
					<h3>Parallels with Natural Languages</h3>

					<table>
						<thead>
						<tr>
							<th>English</th>
							<th>Programming</th>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td>Letter</td>
							<td>Byte</td>
						</tr>
						<tr>
							<td>Word</td>
							<td>Token</td>
						</tr>
						<tr>
							<td>Sentence</td>
							<td>Statement/Program</td>
						</tr>
						<tr class="fragment">
							<td>Grammar</td>
							<td>Grammar</td>
						</tr>
						</tbody>
					</table>

					<aside class="notes">
						<ul>
							<li>
								The point here is that the study of natural languages influenced the theoretical
								development of programming language theory.
							</li>
							<li>Humans process sentences via a set of grammar rules, so do computers.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>Process</h3>

					<section>
						Input: Source file (byte stream)
					</section>
					<section>
						Lexical Analysis
					</section>
					<section>
						Parsing
					</section>
					<section>
						Abstract Syntax Treee
					</section>
				</section>

				<section>
					<h2>Lexical Analysis</h2>
				</section>

				<section>
					<h3>Lexical Analysis</h3>

					<section>
						<ul>
							<li>Bytes to tokens</li>
							<li>Main tool: Regular Expressions</li>
							<li>Historically, <code>flex</code> was used quite often</li>
						</ul>
					</section>

					<section>
						<pre><code class="flex">
[A-Za-z_][A-Za-z0-9_]*                        return 'Identifier'

// 3.1, 3.1e-7
[0-9]+("."[0-9]+)?([eE][\-+]?[0-9]+)?\b       return 'FLOAT_NUMBER'
[0-9]+\b                                      return 'INT_NUMBER'
						</code></pre>

						<aside class="notes">
							This specifies several regexes to match identifiers and numbers. The terms which is
							returned can be used when writing the parsing rules, discussed next.
						</aside>
					</section>
				</section>

				<section>
					<h2>Parsing</h2>
				</section>

				<section>
					<h3>Parsing</h3>

					<section>
						<h3>Chomsky Hierarchy of Languages</h3>
						<table style="font-size: 75%">
							<thead>
							<tr>
								<th>Grammar</th>
								<th>Language</th>
								<th>Automaton</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<th>Type-0</th>
								<td>Recursively Enumerable</td>
								<td>Turing Machine</td>
							</tr>
							<tr>
								<th>Type-1</th>
								<td>Context Sensitive</td>
								<td>Linear-bounded non-deterministic Turing Machine</td>
							</tr>
							<tr>
								<th>Type-2</th>
								<td>Context Free</td>
								<td>Non-deterministic pushdown automaton</td>
							</tr>
							<tr>
								<th>Type-3</th>
								<td>Regular</td>
								<td>Finite State automaton</td>
							</tr>
							</tbody>
						</table>

						<small>*Table in <a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">Wikipedia</a></small>

						<aside class="notes">
							We've already covered regular expressions previously. That actually is the simplest
							possible language.

							The bulk of programming languages are context free languages as far as possible to ease
							the writing of parsers. Some (harder to parse) languages are context sensitive languages.

							You can use a more powerful automaton to parse a language, but not the other way around.
							This is why you should never try to check if a bunch of HTML markup is valid using a regex.
						</aside>
					</section>

					<section>
						<h3>Context free languages</h3>

						<p>We can try to write a context-free grammar for JavaScript</p>
						<p>Typically, grammars are written using Backus-Naur Form (BNF)</p>
					</section>
				</section>

				<section>
					Lexical Analysis
					<section>
						Regular Expressions
					</section>
					<section>Chomsky</section>
				</section>
				<section>Parsing</section>
				<section>Type Checking</section>
				<section>Optimisations</section>
				<section>Interpreters</section>
				<section>Transpilation</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
